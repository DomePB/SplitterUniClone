### Einleitung und sagen der Ziele (Geschäftsziele): Top 5 der Ziele für Stakeholder:

-	Eine Software die über eine Git-Authentifizierung Gruppen erstellen kann, in denen Ausgaben gespeichert und Transaktionen ausgegeben werden können
-	Konten sollen dabei möglichst transparent und einfach ausgeglichen werden

#### Qualitätsziele
Es soll möglichst Wartbar sein. Zudem wollten wir ein gewissen Grad an Accessibility gewährleisten, indem

### Beschränkungen/ Bedingungen

- sollte minimal sein
- Als OAuth-Provider benutzen wir GitHub.
- Onion-Architektur als Architekturmuster
- Die Anwendung soll als Webanwendung mit Spring Boot umgesetzt werden.
- Die Anwendung soll auf Port 9000 laufen
- Als Datenbank wird PostgreSQL verwendet. Die Datenbank muss in einem Docker-Container laufen.
- Datenbank-Tests werden mit H2 umgesetzt und müssen auch laufen, wenn Docker ausgeschaltet ist.
- In der Domänenschicht müssen die taktischen DDD-Muster verwendet werden.
- Google-Styleguides sollen eingehalten werden
- MVP, da straffer Zeitplan

### Kontextabgrenzungen: Inhalt und Umfang (Äußere Systeme) / Buisness und Technologie abgrenzen

package als domäne und nicht abhängig von spring Service abghängiger

-	Business:

### Strategien für Lösungen: zentale Entwufrsentschidungen und Lösungsstrategien
Im Vorhinein:
-Personen zu Gruppen hinzufügen und speichern
-Ausgeben speichern und in Tabelle speichern von welcher Person/an welche Person
Algorithmus für  maximal m-1 Transaktionen (beinahe minimal): Man macht eine Art Matrix, welche die einzelnen Differenzen von Schulden bzw. Salden zwischen Personen in der selben Gruppe berechnet. Bsp:

[options="header"]
|================
| / | A  | B | C | D
| A | 0  | 8 | 5 | 0
| B | 3  | 0 | 7 | 11
| C | 10 | 1 | 0 | 6
| D | 2  | 5 | 4 | 0
|================

Vertikale Summe: Schulden, Horizontale Summe: Salden
Als Beisoiel A schuldet B 8$
Hierbei summieren wir zuerst die vertikalen Summen und die Horizontalen Summen pro User.
So kommen wir beispielsweise bei A auf 13 $ schuldne und 15$ Salden. Diese rechnen wir dann zusammen (Salden-Schulden) und kommen auf 2$.
Falls wir alle nach diesem Verfahren berechnen, kommen wir auf folgende Ergebnisse:
|====
|   User   |   Schulden/Salden
| A | 2$
| B | -1$
| C | -7$
| D | 6$
|====

Um die Transaktionen minimal zu halten, testen wir als Erstes, ob bestimmte Salden und Schulden sich ausgleichen.
Falls dies der Fall ist, werden diese zu Beginn berechnet und schon ausgeglichen. +
Falls dies nicht der Fall ist gehen vergleichen wir herabsteigend alle User miteinander. +

So vergleichen wir in unserem Beispiel zuerst User A mit User B. Dabei sehen wir, dass User B seine ganzen Schulden bei User A egalisieren kann. +
|====
|   User   |   Schulden/Salden
| A | 2$
| B | -1$
|====
Da User B nun bei 0 ist kann, dieser aus der Schuldigenliste entfernt werden. Nun aktualiseren wir den Wert von User A auf 1$ . +
|====
|   User   |   Schulden/Salden
| A | 1$
| C | -7$
| D | 6$
|====
Da User B entfernt wurde vergleichen wir dies mit User C und User C überweist diesen 1$. +
|====
|   User   |   Schulden/Salden

| C | -6$
| D | 6$
|====
Nun aktuaisieren wir User C und geben das restliche Geld User D. +
So haben wir *immer* im Worst-Case _m-1_ Transaktionen. +

---

#### 2. Version: Minimale Ausgabe

Im Vorhinein:
-Personen zu Gruppen hinzufügen und speichern
-Ausgeben speichern und in Tabelle speichern von welcher Person/an welche Person

Man macht vom Prinzip genau wie gerade die Differenzen ausrechnen
-In diesem Fall evrgleicht man zuerst, ob es Schulden und Salden gibt, welche sich ausgleichen. +
Falls dies nicht der Fall ist macht man als Erstes 2 Listen: 1. Liste: Alle die was bekommen, 2. Liste: Alle die was schulden +
Man sortiert die Listen von dem kleinsten Betrag zu dem grössten.
Man nimmt die kleinsten Schulden und summiert diese mit den 2. kleinsten Schulden und vergleicht diese mit den kleinsten Salden. Falls diese sich ausgleichen werden diese Transaktionen gespeichert. +
Falls die Summe dieser Schulden jedoch kleiner ist als die geringsten Salden, wird die Summe mit den 2. kleinsten Salden verglichen. Falls das wieder kleiner ist wird dies mit den 3. kleinsten vergliche usw. +
Falls dann nach einer Zeit jedoch die summierte Summe grösser ist, wird der

### Hierrarchische Struktur des Codes: Zerlegung des Systems alles erklären, tiefer rein in die Blöcke, rein in weitere Blöcke von 2

Application
Adapters
Domain


### Laufzeiten: wie arbeiten Systembausteine mit nachbarsystemen zusammen? Wie werden diese ausgeführt

Onion arbeitet wie folgt miteinander

### Technische Infrastruktur zb hardware, Entwicklungsumgebung, Testumgebung, Produktionsumgebung

Wir haben vertikal gearbeitet
Test was testen wir alles?


### Bereichsübergreifende konzepte



### Architekturentscheidungen: wichtige, teure oder kritische oder riskante Architekturentscheidungen, die zentrale Bedeutung für das Gesamtsystem haben, mit Begründungen für diese Entscheidungen.

### Qualitätsanforderungen: weitere ziele als 1 und wurden diese alle erreicht

### Schwächen, risiken, welche probleme könnte es geben

### 1.	Glossar: Wichtige Domänenbegriffe und technische Begriffe, die Stakeholder kennen sollten, wenn sie über die Architektur des Systems diskutieren. Manchmal auch Übersetzungstabellen, wenn in einer mehrsprachigen Umgebung gerarbeitet

Haben keine schwierigen Begriffe benutzt